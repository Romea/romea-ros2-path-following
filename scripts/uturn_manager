#!/usr/bin/env python3
import time
import rclpy
from rclpy.executors import MultiThreadedExecutor
from rclpy.callback_groups import MutuallyExclusiveCallbackGroup
from rclpy.node import Node

from rclpy.action import ActionServer
from romea_path_msgs.action import UturnDone, Lock

class UturnManager(Node):
    def __init__(self):
        super().__init__("uturn_manager")
        self.lock_state = False

        lock_cb_group = MutuallyExclusiveCallbackGroup()
        self.lock_action = ActionServer(
            self,
            Lock,
            "~/lock",
            self.lock_callback,
            callback_group = lock_cb_group
        )

        uturn_done_cb_group = MutuallyExclusiveCallbackGroup()
        self.uturn_done_action = ActionServer(
            self,
            UturnDone,
            "~/uturn_done",
            self.uturn_done_callback,
            callback_group = uturn_done_cb_group
        )

        self.declare_parameter("robots_nb", 2)
        self.robots_nb = self.get_parameter("robots_nb").get_parameter_value().integer_value
        self.uturn_done_count = 0

        self.logger = self.get_logger()

    def lock_callback(self, goal_handle):
        req_data = goal_handle.request.data
        res = Lock.Result()
        
        if not req_data:
            if self.lock_state:
                self.uturn_done_count += 1
            self.lock_state = False
            self.logger.info("unlocked")
            res.success = True
            res.message = 'unlocked'
            goal_handle.succeed()

        else:
            while self.lock_state:
                if goal_handle.is_cancel_requested:
                    res.success = False
                    res.message = 'canceled'
                    goal_handle.canceled()
                    return res
                # else:
                #     time.sleep(1)

            self.lock_state = True
            self.logger.info("locked")
            res.success = True
            res.message = 'locked'
            goal_handle.succeed()

            if self.uturn_done_count >= self.robots_nb:
                self.uturn_done_count = 0
                self.logger.info("resetting uturn_done counter")

        return res

    def uturn_done_callback(self, goal_handle):
        feedback_msg = UturnDone.Feedback()
        while (self.uturn_done_count < self.robots_nb):
            feedback_msg.robots_done = self.uturn_done_count
            feedback_msg.robots_number = self.robots_nb
            goal_handle.publish_feedback(feedback_msg)
            time.sleep(1)

        goal_handle.succeed()
        return UturnDone.Result()


def main(args=None):
    rclpy.init(args=args)
    executor = MultiThreadedExecutor()
    uturn_manager = UturnManager()
    executor.add_node(uturn_manager)
    try:
        executor.spin()
    except KeyboardInterrupt:
        pass
    
    uturn_manager.destroy_node()
    rclpy.shutdown()


if __name__ == "__main__":
    main()
